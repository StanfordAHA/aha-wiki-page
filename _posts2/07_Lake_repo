---
title: Lake repo explain
author: XXX
date: 2022-09-28
layout: post
---

From [Github repo Correspondence](05_repo_correspondence.md), MEM tile is specified in [`./strg_ub_vec.py`](https://github.com/StanfordAHA/lake/blob/f7f2b501e91ac4764e0f94a9247079adf0eb3d99/lake/modules/strg_ub_vec.py). And Lake architecture overview is explained [here](04_Lake.md). When looking into .py file, we can see lots of module names, so let's try to link those together. 

## StrgUBVec
- inputs: 
    data_from_strg => tb_only
- outputs:
    ren_to_strg <= sram_tb_shared
    wen_to_strg <= sram_only
    addr_out <= sram_only
    data_to_strg <= tb_only
    
data_in, data_out: used for chain

Every MEM tile has its own cycle counter, `cycle_count` in code, which would be used by SG to decide when READ/WRITE enable signal.
Each MEM tile contains two AGGs, one SRAM and two TBs. We devide them into five partitions. 

    StrgUBVec
    +-- StrgUBAggOnly
    +-- StrgUBAggSRAMShared
    +-- StrgUBSRAMOnly
    +-- StrgUBSRAMTBShared
    +-- StrgUBTBOnly


### StrgUBAggOnly

    StrgUBVec
    +-- StrgUBAggOnly
        +-- AddrGen *2
        +-- SchedGen *2 
        +-- ForLoop *2
        +-- agg (register file) 

`AggOnly` conbines two AGGs with **one register file of size 2*4**, to aggrate 4 words each for 2 input ports. This `AggOnly` modules also contains the affine controller between input ports and the register file. Since there are two input ports, it contains **two AGs**, **two SGs** and **two IDs**, specifying the address and enable signal to READ/WRITE AGG. 

AGG is SIPO interface, so the input would be **one 16-bit data word** for each port. After it collects four 16-bit data words, AGG would **output four 16-bit data word** to SRAM at a time. 

    input  [1:0] [15:0] data_in
    output [1:0] [3:0] [15:0] agg_data_out


The **ID module** is specified in [`./for_loop.py`](https://github.com/StanfordAHA/lake/blob/f7f2b501e91ac4764e0f94a9247079adf0eb3d99/lake/modules/for_loop.py), **AG** is in [`./addr_gen.py`](https://github.com/StanfordAHA/lake/blob/f7f2b501e91ac4764e0f94a9247079adf0eb3d99/lake/modules/addr_gen.py), and **SG** is in [`./spec/sched_gen.py`](https://github.com/StanfordAHA/lake/blob/f7f2b501e91ac4764e0f94a9247079adf0eb3d99/lake/modules/spec/sched_gen.py).


#### AG
AG generate **the READ/WRITE address**. For example, AG under `AggOnly` would calculate which address in AGG to be READ/WRITE. Since AGG is a small memory of size 4 data-words, we only need 3 bits for its address. But if the AG is used for SRAM, which can store 512 pairs of 4-data-word, it would need 9 bits for its address. 

We utilize the recurrence relation of ID and **replace multipliers by an adder, a register, and a multiplexer**. AG gets the input `mux_sel` signal from ID, deciding which stride to take to increment the running address. Lake supports up to **6-D loop nest**, so we would need 3 bits for the MUX and we would have 6 stride choices to choose from.

    input  [8:0] starting_addr 
    input  [5:0] [8:0] strides
    input  [2:0] mux_sel
    output [8:0] addr_out


#### SG
SG generate **the READ/WRITE enable signal**. under the control of ID. SG would use the same AG architecture to calculate **the next cycle schedule**. SG would also gets `cycle_count` input from ID, recording **the current cycle number**. It can then compare the two result, and **generate enable signal (`valid_output`)** when the two results match.  

    input  [15:0] cycle_count
    input  [15:0] sched_addr_gen_starting_addr
    input  [5:0] [15:0] sched_addr_gen_strides
    input  [2:0] mux_sel
    output valid_output


#### ID
ID corresponds to **for-loop**. It would output the **`mux_sel` signal** needed by AG and SG. The `ranges` is the **boundary of each loop**, corresponding to **`extent` attribute** in config file. 

    input  [5:0] [9:0] ranges
    input  [3:0] dimensionality    // need to check
    output [2:0] mux_sel_out


> ###### Note
> 
> If the `input` was added additional attribute `ConfigRegAttr`, it means that this `input` signal **could be reconfigured** directly by the compiler. This is where *reconfigurable* array comes from.
{: .block-tip }


### StrgUBAggSRAMShared

    StrgUBVec
    +-- StrgUBAggSRAMShared
        +-- AggSramSharedAddrGen *2
        +-- AggSramSharedSchedGen *2

`AggSRAMShared` only contains the affine controller between AGGs and SRAM. It contains **two AGs** and **two SGs**. SG here is used for generate READ enable from AGG and AG is used to read address for AGG. 

The `agg_read_out` signal is the READ enable signal from SG, and the `agg_sram_shared_addr_out` signal is the READ address for AGG. 
///////// Check this!


    output [1:0] agg_read_out
    output [1:0] [8:0] agg_sram_shared_addr_out



### StrgUBSRAMOnly

    StrgUBVec
    +-- StrgUBSRAMOnly
        +-- AddrGen *2

`SRAMOnly` also only contains the affine controller between AGGs and SRAM. It contains **two AGs**, which are used for generate address for SRAM. Simply say, this block gets the data from agg and then pass WRITE enable, WRITE address and data to SRAM. 

    input  [1:0] [3:0] [15:0] agg_data_out
    input  [1:0] agg_read
    output [3:0] [15:0] data_to_sram
    output [8:0] addr_to_sram
    output wen_to_sram





### StrgUBSRAMTBShared

    StrgUBVec
    +-- StrgUBSRAMTBShared
        +-- SchedGen *2 
        +-- ForLoop *2

`SRAMTBShared` also only contains the affine controller between SRAM and TBs. It contains **two SGs** and **two IDs**. SG here is used for generate READ enable from SRAM. The `t_read_out` signal is the READ enable signal from SRAM. The `loops_sram2tb_mux_sel` signal is generated from ID. We support 6-D so mux sel signal is 3 bits.

    output [1:0] t_read_out
    output [1:0] [2:0] loops_sram2tb_mux_sel


### StrgUBTBOnly

    StrgUBVec
    +-- StrgUBTBOnly
        +-- AddrGen *4
        +-- SchedGen *2 
        +-- ForLoop *2
        +-- tb (register file) 

`TBOnly` conbines two TBs with **one register file of size 2*4**, 4 words each for 2 output ports, act as a transposed buffer between TB and output port. This `TBOnly` modules also contains the affine controller between TBs and output port. It contains **four AGs**, **two SGs** and **two IDs**. Two AGs generate the READ address for SRAM and the other two AGs generate the WRITE address for TB. SG is used to generate  

TB is PISO interface, so the input would be **four 16-bit data word**, and the output would be **one 16-bit data word** for each port. 

    input  [3:0] [15:0] sram_read_data
    output [1:0] [15:0] data_out